/*
 * board_ext_adc.c
 *
 *  Created on: Mar 4, 2019
 *      Author: VNVolokitin
 */



#include "board_ext_adc.h"
#include "stdio.h"
#include "stdlib.h"
#include "board_states.h"

#include "GUI.h"

/* Here we will save ADC bits: */
uint16_t u16_adc_bit_buff[12];

/* Here we will save ADC OVERLOAD signal: */
uint16_t u16_otr_value;

/* This is a buffer to save EXT_ADC_BUFFER numbers of ADC samples: */
int16_t i16_ext_adc_first_buffer[EXT_ADC_BUFFER];
int16_t i16_ext_adc_second_buffer[EXT_ADC_BUFFER];
int16_t i16_ext_adc_raw_average_buffer[EXT_ADC_RAW_AVERAGE_BUFFER];

/* It is a char buffer used for printf: */
char ch_numbers[50];

/* This is main function for initialization external ADC module: */
void board_init_external_adc()
{
	board_ext_adc_clear_buffer();
	board_ext_adc_clear_raw_average_buffer();
}


// Read data to buffer. It is checking buffer index.
void board_ext_adc_read_to_raw_average_buffer(int16_t * pi16_adc_value, uint32_t u32_index)
{
	if(u32_index < EXT_ADC_RAW_AVERAGE_BUFFER)
	{
		*pi16_adc_value = i16_ext_adc_raw_average_buffer[u32_index];
	}
}

// Write data to buffer. It is checking buffer index.
void board_ext_adc_write_to_raw_average_buffer(int16_t i16_adc_value, uint32_t u32_index)
{
	if(u32_index < EXT_ADC_RAW_AVERAGE_BUFFER)
	{
		i16_ext_adc_raw_average_buffer[u32_index] = i16_adc_value;
	}
}

void board_ext_adc_clear_raw_average_buffer()
{
	uint32_t u32_counter = 0;

	/* Clear external ADC RAW AVERAGE buffer: */
	for(u32_counter = 0; u32_counter < EXT_ADC_RAW_AVERAGE_BUFFER; u32_counter++)
	{
		i16_ext_adc_raw_average_buffer[u32_counter] = 0;
	}
}

/* This function clear external ADC data buffer: */
void board_ext_adc_clear_buffer()
{
	uint32_t u32_counter = 0;

	/* Clear external ADC buffer: */
	for(u32_counter = 0; u32_counter < EXT_ADC_BUFFER; u32_counter++)
	{
		i16_ext_adc_first_buffer[u32_counter] = 0;
		i16_ext_adc_second_buffer[u32_counter] = 0;
	}
}

/* This function copy data from first buffer to second:
 * It will be useful for clear graph on display.
 * Just print graph again with background color.
 * */
void board_ext_adc_copy_buffer()
{
	uint32_t u32_counter = 0;

	/* Clear external ADC buffer: */
	// TODO: Can be changed to DMA Mem-To-Mem copy.
	for(u32_counter = 0; u32_counter < EXT_ADC_BUFFER; u32_counter++)
	{
		i16_ext_adc_second_buffer[u32_counter] = i16_ext_adc_first_buffer[u32_counter];
	}
}

#if 0
/* This function read analog raw value from external ADC: */
void board_ext_adc_read_adc_value()
{
	/* ADC value is 12 bits. Max value is 4096.
	 * Input value should be in range from 1V to 3V
	 * Input virtual ground value is 2V.
	 * ADC virtual ground value is 2048 (+- some small amount)
	 *
	 * */
	board_ext_adc_clock();

    /* Read data: */
    u16_value[0]  = READ_D0();
    u16_value[1]  = READ_D1();
    u16_value[2]  = READ_D2();
    u16_value[3]  = READ_D3();
    u16_value[4]  = READ_D4();
    u16_value[5]  = READ_D5();
    u16_value[6]  = READ_D6();
    u16_value[7]  = READ_D7();
    u16_value[8]  = READ_D8();
    u16_value[9]  = READ_D9();
    u16_value[10] = READ_D10();
    u16_value[11] = READ_D11();

    u16_otr_value = READ_OTR();
}
#endif

/* This function read analog raw value from external ADC: */
void board_ext_adc_read_adc_value()
{

	/* ADC value is 12 bits. Max value is 4096.
	 * Input value should be in range from 1V to 3V
	 * Input virtual ground value is 2V.
	 * ADC virtual ground value is 2048 (+- some small amount)
	 *
	 * */
    /* Generate ADC clock: */
	// ADC clock generated by external PWM timer, so we do not need to generate clock by himself.
    //	board_ext_adc_clock();

	/* Read data: */
	u16_adc_bit_buff[0]  = READ_D0();
	u16_adc_bit_buff[1]  = READ_D1();
	u16_adc_bit_buff[2]  = READ_D2();
	u16_adc_bit_buff[3]  = READ_D3();
	u16_adc_bit_buff[4]  = READ_D4();
	u16_adc_bit_buff[5]  = READ_D5();
	u16_adc_bit_buff[6]  = READ_D6();
	u16_adc_bit_buff[7]  = READ_D7();
	u16_adc_bit_buff[8]  = READ_D8();
	u16_adc_bit_buff[9]  = READ_D9();
	u16_adc_bit_buff[10] = READ_D10();
	u16_adc_bit_buff[11] = READ_D11();
#if 0
	/* Read data: */
	u16_adc_bit_buff[11]  = READ_D0();
	u16_adc_bit_buff[10]  = READ_D1();
	u16_adc_bit_buff[9]  = READ_D2();
	u16_adc_bit_buff[8]  = READ_D3();
	u16_adc_bit_buff[7]  = READ_D4();
	u16_adc_bit_buff[6]  = READ_D5();
	u16_adc_bit_buff[5]  = READ_D6();
	u16_adc_bit_buff[4]  = READ_D7();
	u16_adc_bit_buff[3]  = READ_D8();
	u16_adc_bit_buff[2]  = READ_D9();
	u16_adc_bit_buff[1] = READ_D10();
	u16_adc_bit_buff[0] = READ_D11();
#endif

    u16_otr_value = READ_OTR();
}


/* This function generates ONE sample pulse: */
void board_ext_adc_clock()
{
	// TODO: Disable all interrupt here
	// Time critical part of code:
#if 0
	CLOCK_LOW();
	CLOCK_HIGH();
	CLOCK_LOW();
	/* 20 nS delay: */
	CLOCK_LOW();
	CLOCK_LOW();
	CLOCK_LOW();
	CLOCK_LOW();
#endif
	// TODO: Enable all interrupt here
}


/* This function prints ADC data output bits: */
void board_ext_adc_print_bits()
{
	/* Print data: */
    sprintf(ch_numbers,
    		"%d %d%d%d%d%d%d%d%d%d%d%d%d",
            u16_otr_value,
			u16_adc_bit_buff[11],
			u16_adc_bit_buff[10],
			u16_adc_bit_buff[9],
			u16_adc_bit_buff[8],
			u16_adc_bit_buff[7],
			u16_adc_bit_buff[6],
			u16_adc_bit_buff[5],
			u16_adc_bit_buff[4],
			u16_adc_bit_buff[3],
			u16_adc_bit_buff[2],
			u16_adc_bit_buff[1],
			u16_adc_bit_buff[0]
            );

    /* Prinf char buffer to LCD: */
    // TODO: add definition of message position:
    GUI_DispStringAt(ch_numbers, (LCD_GetXSize()-150)/2 - 30, (LCD_GetYSize()-20)/2 + 34);
}


/* This function converts bits array to uint16 and return int16 with level shift: */
void board_ext_adc_get_adc_value(int16_t * pi16_value)
{
    /* Convert data to value: */
    uint32_t i = 0;
	uint16_t u16_adc_value = 0;
	int16_t i16_adc_value = 0;
	int16_t i16_tmp = 0;

	// TODO: check bits orders:
    for( i = 0; i < GUI_COUNTOF(u16_adc_bit_buff); i++)
    {
        u16_adc_value = u16_adc_value + (u16_adc_bit_buff[11 - i]<<i) ;
    }

	board_set_uint32_state(RAW_ADC_VALUE, u16_adc_value);

    i16_adc_value = u16_adc_value;
    // TODO: Define level shift:
    //i16_tmp = i16_adc_value - 2048 - 3;
    i16_tmp = 2048 + 4 - i16_adc_value;

    /* Return value: */
    *pi16_value = i16_tmp;
}


/* This function prints ADC integer decimal value: */
void board_ext_adc_print_adc_value(int16_t i16_value)
{
	sprintf(ch_numbers,"%d           ",i16_value);
	// TODO: Define message position:
	GUI_DispStringAt(ch_numbers, (LCD_GetXSize()-150)/2-30, (LCD_GetYSize()-20)/2 + 68);
}

/* This function does one time  reading ADC: */
void board_ext_adc_one_time_read_sequence(int16_t * pi16_value)
{
	/* STEP_0: Read ADC bits*/
	board_ext_adc_read_adc_value();

    /* STEP_1: Convert bits to int16 with level shift and return it: */
	board_ext_adc_get_adc_value(pi16_value);
}


